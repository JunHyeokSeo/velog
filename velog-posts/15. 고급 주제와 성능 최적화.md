<h1 id="154-성능-최적화">15.4 성능 최적화</h1>
<h2 id="1541-n1-문제">15.4.1 N+1 문제</h2>
<p>연관관계를 갖는 엔티티를 JPQL로 조회할 때 문제가 발생한다. </p>
<h3 id="즉시로딩과-n1-문제">즉시로딩과 N+1 문제</h3>
<p>회원과 주문 정보는 1:N, N:1 연관관계다. 
그리고 회원이 참조하는 주문정보인 Member.orders를 즉시로딩으로 설정했다.
em.find로 조회 시 JOIN을 사용하여 문제가 없지만 JPQL 사용 시 JPA는 즉시로딩과 지연로딩에 대해 전혀 신경 쓰지 않고 JPQL만 사용해서 SQL을 생성한다. 따라서 Member를 조회하는 SQL 한 번으로 5명의 Member 엔티티를 조회했다고 했을 때, 각 Member의 orders를 조회하는 SQL이 5번 실행되는 문제가 발생한다.
이처럼 처음 실행한 SQL의 결과 수만큼 추가로 SQL을 실행하는 것을 N+1 문제라 한다.
<code>즉시로딩은 JPQL을 실행할 때 N+1 문제가 발생할 수 있다.</code></p>
<h3 id="지연로딩과-n1-문제">지연로딩과 N+1 문제</h3>
<p>지연로딩으로 설정하면 JPQL에서 N+1 문제가 발생하지 않는다.
문제는 Member에 연관된 orders 컬렉션을 사용하려고 할 때 발생한다.
loop를 통해 member의 orders 컬렉션을 초기화 한다고 하면 초기화 하는 수만큼 SQL이 실행될 수 있다. 
회원이 5명이면 회원에 따른 주문도 5번 조회된다. 
이것도 결국 N+1 문제다.</p>
<h3 id="페치-조인-사용">페치 조인 사용</h3>
<p>페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조히하므로 N+1 문제가 발생하지 않는다.</p>
<h3 id="하이버네이트-batchsize">하이버네이트 @BatchSize</h3>
<p><code>@BatchSize</code> 어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 <code>IN 절</code>을 사용해서 조회한다. 
조회한 회원이 10명인데 <code>size=5</code>로 지정하면 2번의 SQL만 추가로 실행한다.</p>
<h3 id="n1-정리">N+1 정리</h3>
<p>즉시로딩과 지연로딩 중 추천하는 방법은 즉시 로딩은 사용하지 말고 지연로딩만 사용하는 것이다. 
즉시로딩은 N+1 문제는 물론이고 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩해야 하는 상황이 자주 발생한다. 
그리고 가장 큰 문제는 성능 최적화가 어렵다는 점이다.
모두 지연로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.</p>
<h2 id="1542-읽기-전용-쿼리의-성능-최적화">15.4.2 읽기 전용 쿼리의 성능 최적화</h2>
<p>영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다.
읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다.</p>
<h3 id="스칼라-타입으로-읽기">스칼라 타입으로 읽기</h3>
<p>스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.</p>
<h3 id="읽기-전용-쿼리-힌트-사용">읽기 전용 쿼리 힌트 사용</h3>
<p>하이버네이트 전용 힌트인 org.hibernate.readOnly를 사용하면 엔티티를 읽기 전용으로 조회할 수 있다.
읽기 전용이므로 스냅샷을 보관하지 않는다. 
따라서 엔티티를 수정해도 데이터베이스에 반영되지 않는다.</p>
<h3 id="읽기-전용-트랜잭션-사용">읽기 전용 트랜잭션 사용</h3>
<p>트랜잭션에 <code>readOnly = true</code> 옵션을 주면 스프링 프레임워크가 하이버네이트 세션의 플러시 모드를 <code>MANUAL</code>로 설정한다. 
이렇게 하면 강제로 플러시를 호출하지 않는 한 플러시가 일어나지 않는다. 
트랜잭션을 커밋해도 영속성 컨텍스트를 <code>flush</code>하지 않는다. 
영속성 컨텍스트를 <code>flush</code>하지 않으니 엔티티의 등록, 수정, 삭제는 당연히 동작하지 않는다. 
플러시할 때 일어나는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상된다.</p>
<blockquote>
<p>메모리를 최적화하려면 스칼라 타입으로 조회하거나 하이버네이트가 제공하는 읽기 전용 쿼리 힌트를 사용하면 되고 플러시 호출을 막아서 속도를 최적화하려면 읽기 전용 트랜잭션을 사용하거나 트랜잭션 밖에서 읽기를 사용하면 된다.
<code>읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트(또는 스칼라 타입으로 조회)</code>를 동시에 사용하는 것이 효과적이다.</p>
</blockquote>
<h2 id="1543-배치-처리">15.4.3 배치 처리</h2>
<p>수백만 건의 데이터를 배치 처리해야 하는 상황에서 일반적인 방식으로 엔티티를 계속 조회하면 영속성 컨텍스트에 아주 많은 데이터가 쌓이면서 메모리 부족 오류가 발생한다. 
따라서 배치 처리는 <code>적절한 단위로 영속성 컨텍스트를 초기화</code>해야 한다. 
또한 2차 캐시를 사용하고 있다면 <code>2차 캐시에 엔티티를 보관하지 않도록 주의</code>해야 한다.</p>