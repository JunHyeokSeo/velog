<h1 id="빈-스코프란">빈 스코프란?</h1>
<p>스코프는 빈이 존재할 수 있는 범위를 의미
<code>@Scope</code> 어노테이션을 통해 스코프 지정
<code>@Scope(“singleton”)</code>, <code>@Scope(“prototype”)</code> 등</p>
<h3 id="다양한-스프링-스코프">다양한 스프링 스코프</h3>
<ol>
<li><p>싱글톤: 기본 스코프, <code>스프링 컨테이너의 시작과 종료까지 유지</code>되는 가장 넓은 범위의 스코프</p>
</li>
<li><p>프로토타입: 스프링 컨테이너는 <code>프로토타입 빈의 생성과 의존관계 주입까지만 관여</code>하는, 매우 짧은 범위의 스코프</p>
</li>
<li><p>웹 관련 스코프</p>
<ol>
<li><p>request: 웹 요청이 들어오고 나갈 때까지 유지</p>
</li>
<li><p>session: 웹 세션이 생성되고 종료될 때까지 유지</p>
</li>
<li><p>application: 웹의 서블릿 컨텍스트와 같은 범위로 유지</p>
<h1 id="프로토타입-스코프">프로토타입 스코프</h1>
<p>스프링 컨테이너에 요청할 때마다 새로 생성된다.
스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다
<code>@PreDestroy</code> 같은 소멸 콜백 메서드가 호출되지 않는다.
그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다.
종료 메서드에 대한 호출도 클라이언트가 직접 해야 한다.</p>
<h3 id="싱글톤-빈과-함께-사용-시-문제점">싱글톤 빈과 함께 사용 시 문제점</h3>
<p>싱글톤 빈이 프로토타입 빈을 멤버변수로 참조 하고 있고 의존관계 주입을 받는다면, <code>싱글톤 빈 인스턴스 생성 시 프로토타입 빈을 입력 받고 싱글톤 빈 소멸까지 해당 프로토타입 빈을 참조</code>한다.
따라서 매 클라이언트 요청마다 새로운 프로토타입 빈을 생성하고 참조하려는 의도와 다르게 동작할 수 있다.
프로토타입 빈을 주입 시점에만 새로 생성하는 것이 아니라, 사용할 때마다 새로 생성하기 위해 <code>Provider</code> 사용.</p>
<h3 id="싱글톤프로토타입-빈을-함께-사용할-때-사용할-때마다-새로운-프로토타입-빈-생성---provider">싱글톤/프로토타입 빈을 함께 사용할 때, 사용할 때마다 새로운 프로토타입 빈 생성 - Provider</h3>
<h4 id="해결-방법-1---applicationcontext-주입">해결 방법 1 - ApplicationContext 주입</h4>
<p><code>ApplicationContext</code>를 싱글톤 빈에서 주입 받아서 필요한 프로토타입 빈을 조회하고 로직 실행
의존관계를 외부에서 주입 받는 것이 아니라, 이렇게 직접 필요한 의존관계를 찾는 것을 <code>Dependency Lookup(DL)</code>, <code>의존관계 조회(탐색)</code>이라 한다.
이렇게 스프링의 <code>ApplicationContext</code> 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워 진다.
지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 DL 정도의 기능만 제공하는 무언가가 있으면 된다.</p>
<h4 id="해결-방법-2---objectprovider">해결 방법 2 - ObjectProvider</h4>
<p><code>ObjectProvider</code>는 <code>ObjectFactory</code>를 상속 받아 추가적인 편의기능을 제공
두 방법 모두 스프링에 의존적</p>
<pre><code class="language-java">@Scope("singleton")
static class ClientBean {
@Autowired //PrototypeBean을 찾아주는 기능만 제공
private ObjectProvider&lt;PrototypeBean&gt; prototypeBeanProvider;

public int logic() {
  PrototypeBean prototypeBean = prototypeBeanProvider.getObject();
  prototypeBean.addCount();
  return prototypeBean.getCount();
}
}</code></pre>
<h4 id="해결-방법3---jsr-330-provider">해결 방법3 - JSR-330 Provider</h4>
<p><code>javax.inject:javax.inject:1</code> 라이브러리를 <code>dependencies</code>에 추가해줘야 한다
자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기 훨씬 쉬워진다.</p>
<pre><code class="language-java">@Scope("singleton")
static class ClientBean {
@Autowired
private Provider&lt;PrototypeBean&gt; prototypeBeanProvider;

public int logic() {
  //get() 메소드만 제공
  PrototypeBean prototypeBean = prototypeBeanProvider.get();
  prototypeBean.addCount();
  return prototypeBean.getCount();
}
}</code></pre>
<h3 id="정리">정리</h3>
<p>실무에서 프로토타입 빈을 사용하는 경우는 매우 드물다
스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 자바 표준인 <code>JSR-330 Provider</code> 사용
그렇지 않다면 스프링이 제공하는 <code>ObjectProvider</code> 사용
해당 기능뿐만 아니라 다른 기능들도 자바 표준과 스프링이 제공하는 기능이 겹칠 때가 많은데, 대부분 스프링이 다양하고 편리한 기능을 제공하기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다.</p>
<h1 id="웹-스코프">웹 스코프</h1>
<h2 id="특징">특징</h2>
<p>웹 환경에서만 동작
스프링이 해당 스코프의 종료시점까지 관리, 따라서 소멸 콜백 메서드 호출 가능</p>
<h2 id="종류">종류</h2>
</li>
</ol>
</li>
<li><p>request
HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프
각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성</p>
</li>
<li><p>session
HTTP Session과 동일한 생명주기를 가지는 스코프</p>
</li>
<li><p>application
서블릿 컨텍스트와 동일한 생명주기를 가지는 스코프</p>
</li>
<li><p>websocket
웹 소켓과 동일한 생명주기를 가지는 스코프</p>
<h1 id="request-스코프">Request 스코프</h1>
<p>각 HTTP 요청 별로 로그를 구분해서 출력하고 싶을 때 로거 Bean을 request 별로 관리하고 요청이 구분되게 로그를 찍을 수 있다. 예를 들어 <code>MyLogger</code>라는 Bean을 작성한다. 해당 Bean은 요청에 대한 <code>UUID</code> 및 <code>요청 URL</code>등을 가진다. 스코프를 request로 선언한 뒤 로깅이 필요한 Bean에 주입한다면 각 Bean에서 HTTP 요청 별 로그를 찍을 수 있게 된다.</p>
<h3 id="의존관계-주입에서의-오류">의존관계 주입에서의 오류</h3>
<p>다만 이때 Bean 생성 및 의존관계 주입 과정에서 오류가 발생한다. HTTP 요청이 들어왔을 때 생성되는 MyLogger Bean을 컨테이너 생성 시점에 주입하려고 하니 Bean이 생성되지 않아서 오류가 발생하는 것이다. </p>
<h3 id="provider를-사용하여-해결">Provider를 사용하여 해결</h3>
<p>이는 Provider를 사용하여 해결 할 수 있다. <code>ObjectPrivider&lt;MyLogger&gt;</code> 형태로 감싸 의존관계를 주입하면, HTTP 요청이 들어왔을 때 Provider를 통해 MyLogger Bean을 찾아 사용할 수 있다.
또한 request 스코프 Bean의 경우 생성/소멸 콜백 호출도 가능하다.</p>
<h3 id="proxy를-사용하여-해결">Proxy를 사용하여 해결</h3>
<p><code>@Scope(value = “request”, proxyMode = ScopedProxyMode.TARGET_CLASS)</code>와 같이 프록시 모드를 설정하여 해결할수도 있다.</p>
<h3 id="scopedproxymode-종류-및-특징">ScopedProxyMode 종류 및 특징</h3>
<table>
<thead>
<tr>
<th align="center"><strong>모드</strong></th>
<th align="center"><strong>설명</strong></th>
<th align="center"><strong>주요 특징</strong></th>
<th align="center"><strong>사용 조건</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">NO (기본값)</td>
<td align="center">프록시 사용 안 함</td>
<td align="center">스코프가 짧은 빈을 직접 주입 시 오류 발생</td>
<td align="center">기본값, 오류 발생 가능</td>
</tr>
<tr>
<td align="center">INTERFACES</td>
<td align="center">JDK 동적 프록시 사용</td>
<td align="center">프록시 객체는 <strong>인터페이스 기반</strong>으로 생성됨</td>
<td align="center">해당 빈이 인터페이스를 반드시 구현해야 함</td>
</tr>
<tr>
<td align="center">TARGET_CLASS</td>
<td align="center">CGLIB 기반 클래스 프록시</td>
<td align="center"><strong>클래스 자체를 프록시</strong>로 감쌈 (인터페이스 불필요)</td>
<td align="center">POJO 클래스에도 적용 가능</td>
</tr>
<tr>
<td align="center">DEFAULT</td>
<td align="center">자동 선택 (보통 NO)</td>
<td align="center">Spring 내부 기본 전략 따름</td>
<td align="center">실질적 제어 어려움, 비추천</td>
</tr>
</tbody></table>
</li>
</ol>