<h2 id="1311-스프링-컨테이너의-기본-전략">13.1.1 스프링 컨테이너의 기본 전략</h2>
<p>스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용
같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근
엔티티 매니저는 달라도 같은 영속성 컨텍스트를 사용한다.
같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.
스프링이나 j2EE <code>컨테이너</code>의 가장 큰 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점이다.</p>
<h1 id="132-준영속-상태와-지연로딩">13.2 준영속 상태와 지연로딩</h1>
<p>트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료된다
조회한 엔티티가 컨트롤러나 뷰 같은 프리젠테이션 계층에서는 준영속 상태가 된다.
엔티티를 지연로딩으로 설정해서 프록시 객체로 조회했다고 가정했을 때, 준영속 상태는 영속성 컨텍스트가 없으므로 지연로딩을 할 수 없다. 이 때 지연로딩을 시도하면 <code>LazyInintializationException</code> 예외가 발생한다.
준영속 상태의 지연 로딩 문제를 해결하는 방법은 크게 2가지</p>
<ol>
<li><p>뷰가 필요한 엔티티를 미리 로딩</p>
</li>
<li><p>OSIV를 사용해서 엔티티를 항상 영속 상태로 유지</p>
<h2 id="1321-글로벌-페치-전략-수정">13.2.1 글로벌 페치 전략 수정</h2>
<p>글로벌 페치 전략을 즉시 로딩으로 수정
N+1 문제가 발생할 수 있어 성능에 치명적이다</p>
<h2 id="1322-jpql-페치-조인">13.2.2 JPQL 페치 조인</h2>
<p>글로벌 페치 전략을 즉시 로딩으로 설정하면 N+1 문제가 발생할 수 있는데, 이는 JPQL 패치조인으로 해결할 수 있다. 
페치 조인을 사용하면 SQL JOIN을 사용해서 페치 조인 대상까지 함께 조회한다. 따라서 N+1 문제가 발생하지 않는다. <code>(연관된 엔티티를 이미 로딩했으므로 글로벌 페치 전략 무의미)</code>
현실적인 대안이긴 하지만 무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가할 수 있다.
뷰 각각에 필요한 메소드를 리포지토리에 만들고 이를 호출하게 되면 최적화는 가능하지만 뷰와 리포지토리 간 논리적인 의존관계가 발생한다.
대안으로는 메소드를 하나만 만들고 필요한 엔티티를 페치 조인으로 함께 조회하는 것이다. 
일부 엔티티가 필요 없는 화면에서는 로딩 시간이 증가하겠지만 JOIN을 사용해서 쿼리 한 번으로 데이터를 조회하므로 성능에 미치는 영향이 미미하다. 
<code>무분별한 최적화로 프리젠테이션 계층과 데이터 접근 계층 간에 의존관계가 급격하게 증가하는 것보다는 적절한 선에서 타협점을 찾는 것이 합리적</code></p>
<h2 id="1323-강제로-초기화">13.2.3 강제로 초기화</h2>
<p>영속성 컨텍스트가 살아있을 때 프리젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법.
프록시를 초기화 하는 역할을 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다.
프록시 초기화 역할을 분리하기 위해 <code>FACADE</code> 계층을 사용할 수 있다. 
<code>FACADE</code>는 프리젠테이션 계층과 도메인 모델 계층 간의 논리적 의존성을 분리할 수 있지만, 중간에 계층이 하나 더 끼어듦으로 인해 결국 더 많은 코드를 작성해야 한다는 것이 단점이다. 그리고 <code>FACADE</code>에는 단순히 서비스 계층을 호출하는 위임 코드가 상당히 많을 것이다.</p>
<h1 id="133-osiv">13.3 OSIV</h1>
<p><code>OSIV(Open Session In View)</code>는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻
영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지된다. 따라서 뷰에서도 지연로딩을 사용할 수 있다.
과거 <code>요청 당 트랜잭션 방식</code>의 <code>OSIV</code>는 컨트롤러나 뷰 같은 프리젠테이션 계층이 <code>엔티티를 변경</code>할 수 있다는 단점이 있었고, 최근에는 비즈니스 계층에서만 트랜잭션을 유지하는 방식의 OSIV를 사용한다.</p>
<h2 id="1332-스프링-osiv-비즈니스-계층-트랜잭션">13.3.2 스프링 OSIV: 비즈니스 계층 트랜잭션</h2>
<p>스프링 프레임워크가 제공하는 OSIV는 <code>비즈니스 계층에서 트랜잭션을 사용하는 OSIV</code>다. </p>
</li>
<li><p>클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 영속성 컨텍스트를 생성. 단 이 때 트랜잭션은 시작하지 않는다.</p>
</li>
<li><p>서비스 계층에서 <code>@Transactional</code>로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작</p>
</li>
<li><p>서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이때 트랜잭션은 끝내지만 영속성 컨택스트는 종료하지 않는다.</p>
</li>
<li><p>컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속상태를 유지한다.</p>
</li>
<li><p>서블릿 필터나 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 <code>flush</code>를 호출하지 않고 바로 종료한다.</p>
<h3 id="트랜잭션-없이-읽기">트랜잭션 없이 읽기</h3>
<p>영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다.
엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜잭션이 없어도 되는데 이를 트랜잭션 없이 읽기(<code>Nontransactional reads</code>)라 한다.</p>
<blockquote>
<p><strong>OSIV 환경에서 트랜잭션 없이도 가능한 조회와 커넥션 사용 흐름</strong>
OSIV가 활성화된 경우, 트랜잭션 없이도 조회 쿼리를 실행할 수 있다. 요청이 시작되면 <code>EntityManager</code>는 열리지만, 실제 DB 커넥션은 쿼리를 실행하는 시점에 커넥션 풀에서 획득된다. 조회 쿼리를 실행하면 이때 커넥션이 할당되고, 이후 컨트롤러에서 엔티티를 뷰에 전달하더라도 영속성 컨텍스트는 열려 있으므로 Lazy 로딩이 가능하다. 뷰 렌더링 중 지연 로딩이 발생하면 다시 쿼리가 실행되며, 커넥션은 유지 중이거나 풀에서 재할당된다.</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>요청 범위 내 커넥션 유지와 재할당</strong>
<code>Hibernate</code>는 기본적으로 요청 범위 내에서 커넥션을 유지하려 하지만, flush나 트랜잭션 종료 등 특정 시점에 커넥션이 중간에 반납될 수 있다. 이 경우 이후의 지연 로딩 쿼리는 커넥션 풀에서 새로 커넥션을 할당받아 실행된다. 요청이 완료되면 <code>EntityManager</code>가 닫히고 남은 커넥션도 반환된다.
결과적으로 커넥션은 트랜잭션이 없어도 쿼리 실행 시점마다 필요하며, 상황에 따라 동일 커넥션이 유지되거나 중간에 재할당될 수 있다.</p>
</blockquote>
<blockquote>
<p><strong>스프링 트랜잭션과 DB 트랜잭션의 관계</strong>
스프링 트랜잭션이 시작되면 내부적으로 트랜잭션 매니저가 작동하여 DB 트랜잭션도 반드시 시작된다. 따라서 스프링 트랜잭션이 있으면 DB 트랜잭션도 항상 존재한다. 반대로 DB 트랜잭션이 발생했더라도 스프링 트랜잭션이 없는 경우는 존재할 수 있다. 대표적인 예가 <code>OSIV</code> 환경에서 <code>@Transactional</code> 없이 조회를 수행할 때이며, 이 경우 <code>Hibernate</code>는 DB 커넥션을 획득해 <code>auto-commit</code> 모드로 쿼리를 실행하고 즉시 커밋한다. 또한 <code>JDBC</code>를 직접 사용하는 경우에도 스프링 트랜잭션 없이 DB 트랜잭션이 개별적으로 실행될 수 있다. 즉, 스프링 트랜잭션은 항상 DB 트랜잭션을 수반하지만, DB 트랜잭션은 스프링 트랜잭션 없이도 발생할 수 있다.</p>
</blockquote>
<h3 id="스프링-osiv-주의사항">스프링 OSIV 주의사항</h3>
<p>스프링 OSIV를 사용하면 프리젠테이션 계층에서 엔티티를 수정한 직후 트랜잭션을 시작하는 서비스 계층을 호출하면 문제가 발생한다.
영속성 컨텍스트가 유지 되기 때문에 새로운 트랜잭션이 생성되고 커밋될 때 <code>flush</code> 되어 수정사항이 데이터베이스에 반영된다.</p>